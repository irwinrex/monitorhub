controller:
  # Enable creating an IngressClass for HAProxy ("haproxy") so it will handle matching Ingresses:contentReference[oaicite:0]{index=0}:contentReference[oaicite:1]{index=1}
  ingressClassResource:
    enabled: true
    name: haproxy

  # (Optional) Explicitly set the ingressClass name (defaults to "haproxy" if omitted)
  ingressClass: haproxy

  # Expose HAProxy via a Kubernetes Service of type LoadBalancer (for external access):contentReference[oaicite:2]{index=2}
  service:
    type: LoadBalancer

    # Preserve the client source IP by using externalTrafficPolicy: Local:contentReference[oaicite:3]{index=3}
    externalTrafficPolicy: Local

    # Example annotations for cloud LBs (uncomment and customize per provider):
    #   AWS (cross-zone load balancing, internal LB):
    #     service.beta.kubernetes.io/aws-load-balancer-cross-zone-load-balancing-enabled: "true"
    #     service.beta.kubernetes.io/aws-load-balancer-internal: "0.0.0.0/0"
    #   GKE (internal LB example):
    #     cloud.google.com/load-balancer-type: "Internal"
    #   Azure (internal LB):
    #     service.beta.kubernetes.io/azure-load-balancer-internal: "true"
    annotations:
      #service.beta.kubernetes.io/aws-load-balancer-cross-zone-load-balancing-enabled: "true"
      #service.beta.kubernetes.io/aws-load-balancer-internal: "0.0.0.0/0"
      #cloud.google.com/load-balancer-type: "Internal"
      #service.beta.kubernetes.io/azure-load-balancer-internal: "true"

    # For static IP (MetalLB, Cilium LB IPAM or reserved cloud IP):
    #   Uncomment the following and set your static IP:
    # loadBalancerIP: "192.0.2.100"

    # Configure service ports for HTTP and HTTPS (80/443):contentReference[oaicite:4]{index=4}:
    # Map port 80 to container targetPort 80 (HTTP)
    httpPorts:
      - port: 80
        targetPort: 80
    # Map port 443 to container targetPort 443 (HTTPS)
    httpsPorts:
      - port: 443
        targetPort: 443

  # Secure defaults for resource requests/limits to ensure controller stability:contentReference[oaicite:5]{index=5}:
  resources:
    limits:
      cpu: "500m"
      memory: "512Mi"
    requests:
      cpu: "250m"
      memory: "256Mi"

  # Run two replicas for high availability (HAProxy docs/examples often use 2 for HA):contentReference[oaicite:6]{index=6}.
  replicaCount: 2
# IngressClass resource name used by HAProxy is "haproxy" (default); ensure your Ingresses specify ingressClassName: "haproxy".
# (The Helm chart will create IngressClass "haproxy" because ingressClassResource.enabled=true):contentReference[oaicite:7]{index=7}:contentReference[oaicite:8]{index=8}.
